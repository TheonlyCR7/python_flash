

拦截器（Interceptor）是一种用于拦截请求和响应的机制。它允许开发者在请求到达目标路由或视图函数之前（请求拦截），以及在视图函数执行后生成响应之前（响应拦截）执行特定的逻辑。

在 Flask 中，拦截器通常通过以下两种方式实现：

1. **钩子函数（Hook Functions）**
   - 使用 Flask 提供的装饰器（如 `@app.before_request` 和 `@app.after_request`）来拦截请求和响应。
2. **中间件（Middleware）**
   - 自定义中间件可以处理每个请求和响应，适用于需要全局作用的逻辑。



## 作用

1. **请求验证**
   - 在用户请求到达视图函数之前，检查用户的身份认证、权限验证等。
   - 例如，验证用户是否登录，检查请求头中是否包含有效的 Token。
2. **日志记录**
   - 记录所有的请求和响应，便于审计和调试。
3. **全局预处理**
   - 在请求到达视图函数之前，进行一些全局的逻辑处理，如参数校验、统一处理跨域请求等。
4. **统一响应处理**
   - 格式化所有的响应，确保返回的数据结构统一。
5. **性能监控**
   - 记录请求的处理时间，帮助分析性能瓶颈。

![image-20250114232205620](https://s2.loli.net/2025/01/14/iNYMTlpxyg7b6no.png)

## 拦截器的实现方式

**1. 钩子函数实现**

**常见的钩子函数**

1. **`@app.before_request`**
   - 在每个请求到达视图函数之前执行。
2. **`@app.after_request`**
   - 在视图函数执行后生成响应之前执行。
3. **`@app.teardown_request`**
   - 在请求处理完成后，无论是否有异常，都会执行。
4. **`@app.teardown_appcontext`**
   - 在应用上下文结束时执行（适用于清理资源）。

```python
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.before_request
def before_request():
    print("Before Request: Intercepted")
    # 可进行权限验证等操作
    if not request.headers.get("Authorization"):
        return jsonify({"error": "Unauthorized"}), 401

@app.after_request
def after_request(response):
    print("After Request: Processing Response")
    # 可对响应数据进行统一格式化
    response.headers["Custom-Header"] = "Intercepted"
    return response

@app.teardown_request
def teardown_request(exception):
    print("Teardown Request: Cleaning Up")
    # 清理操作，如关闭数据库连接
    if exception:
        print(f"Exception: {exception}")

@app.route("/")
def home():
    return "Welcome to Flask Interceptor Example!"

if __name__ == "__main__":
    app.run(debug=True)
```



与中间件的实现相比较

```python
from flask import Flask, request

app = Flask(__name__)

class CustomMiddleware:
    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        # 在请求到达 Flask 之前
        print("Middleware: Before Request")
        
        # 调用 Flask 应用
        response = self.app(environ, start_response)
        
        # 在响应离开 Flask 之后
        print("Middleware: After Request")
        
        return response

app.wsgi_app = CustomMiddleware(app.wsgi_app)

@app.route("/")
def home():
    return "Middleware Example"

if __name__ == "__main__":
    app.run(debug=True)
```



## 拦截器和中间件的比较

| 特性         | 拦截器（Hook）                 | 中间件                       |
| ------------ | ------------------------------ | ---------------------------- |
| **作用范围** | 视图函数执行前后               | 请求进入和离开 Flask 应用时  |
| **实现方式** | 使用 Flask 的钩子函数          | 定义 WSGI 中间件             |
| **灵活性**   | 适合处理特定路由或模块         | 适合处理全局逻辑             |
| **使用难度** | 易于实现，Flask 提供了原生支持 | 实现稍复杂，需要操作 WSGI 层 |